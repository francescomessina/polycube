/*
 * Copyright 2018 The Polycube Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//Modify these methods with your own implementation


#include "Sharednic.h"
#include <tins/ethernetII.h>
#include <tins/tins.h>

// files generated by cmake from "Sharednic_dp_{ingress, egress}.c
#include "Sharednic_dp_ingress.h"
#include "Sharednic_dp_egress.h"

enum {
  SLOWPATH_ARP = 1
};

using namespace polycube::service;

Sharednic::Sharednic(const std::string name, const SharednicJsonObject &conf, CubeType type)
  : Cube(name, {generate_code()}, {sharednic_code_egress}, type, conf.getPolycubeLoglevel()) {
  //: Cube(name, {generate_code()}, type, conf.getPolycubeLoglevel()) {
  logger()->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [Sharednic] [%n] [%l] %v");
  // TODO: this should be done at initalization time
  if (conf.loglevelIsSet()) {
    setLoglevel(conf.getLoglevel());
  }

  logger()->info("creating Sharednic instance");

  // TODO: action should have a default value, so the actionIsSet control could be ommitted.
  if (conf.actionIsSet()) {
    setAction(conf.getAction());
  } else {
    setAction(SharednicActionEnum::LINUX);
  }


  // set an initial state before doing any change to the configuration
  // UINT16_MAX means that the port is not connected
  auto ports_map = get_array_table<uint16_t>("ports_map");
  ports_map.set(0, UINT16_MAX);
  ports_map.set(1, UINT16_MAX);

  addPortsList(conf.getPorts());


  // Create two ports: interface and polycube
  // interface
  PortsJsonObject conf_port;
  std::string name_port = "interface";
  conf_port.setName(name_port);

  auto p0 = add_port<PortsJsonObject>(name_port, conf_port);
  logger()->info("port {0} is added", name_port);

  auto ports_table = get_array_table<uint16_t>("ports_map");

  uint32_t port_map_index = 0x0;

  ports_table.set(port_map_index, p0->index());

  // polycube
  name_port = "polycube";
  conf_port.setName(name_port);

  auto p1 = add_port<PortsJsonObject>(name_port, conf_port);
  logger()->info("port {0} is added", name_port);

  port_map_index = 0x1;

  ports_table.set(port_map_index, p1->index());
}


Sharednic::~Sharednic() {
  logger()->info("destroying sharednic instance");
}

void Sharednic::update(const SharednicJsonObject &conf) {
  // This method updates all the object/parameter in Sharednic object specified in the conf JsonObject.
  // You can modify this implementation.

  if (conf.loglevelIsSet()) {
    setLoglevel(conf.getLoglevel());
  }

  if (conf.actionIsSet()) {
    setAction(conf.getAction());
  }

  if (conf.portsIsSet()) {
    for (auto &i : conf.getPorts()) {
      auto name = i.getName();
      auto m = getPorts(name);
      m->update(i);
    }
  }
}

SharednicJsonObject Sharednic::toJsonObject() {
  SharednicJsonObject conf;

  conf.setName(getName());

  conf.setUuid(getUuid());

  conf.setType(getType());

  conf.setLoglevel(getLoglevel());

  conf.setAction(getAction());

  for (auto &i : getPortsList()) {
    conf.addPorts(i->toJsonObject());
  }

  return conf;
}

std::string Sharednic::generate_code() {
  return sharednic_code_ingress;
}

std::vector<std::string> Sharednic::generate_code_vector(){
  throw std::runtime_error("method Sharednic::generate_code_vector not implemented");
}

SharednicActionEnum Sharednic::getAction(){
  uint8_t value = get_array_table<uint8_t>("action_map").get(0x0);
  return static_cast<SharednicActionEnum>(value);
}

void Sharednic::setAction(const SharednicActionEnum &value){
  uint8_t action = static_cast<uint8_t>(value);
  get_array_table<uint8_t>("action_map").set(0x0, action);
}

void Sharednic::packet_in(Ports &port, polycube::service::PacketInMetadata &md, const std::vector<uint8_t> &packet){
  logger()->debug("packet arrived to the slowpath from port {0}", port.name());

  switch (md.reason) {
    case SLOWPATH_ARP: {
      EthernetII p(&packet[0], packet.size());

      for (auto &it : get_ports()) {
        if (it->name() == "polycube" && port.name() == "interface" && it->peer() != "") {
          logger()->debug("ARP packet send out from port {0} connected to {1}", it->name(), it->peer());
          it->send_packet_out(p);
        }
        if (it->name() == "interface" && port.name() == "polycube" && it->peer() != "") {
          logger()->debug("ARP packet send out from port {0} connected to {1}", it->name(), it->peer());
          it->send_packet_out(p);
        }
      }
      break;
    }
    default:
      logger()->error("not valid reason {0} received", md.reason);
      break;
  }

}
